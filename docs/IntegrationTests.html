<!DOCTYPE html>
<html>
<head>
<title>IntegrationTests.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="integration-tests">Integration tests</h1>
<h2 id="approaching-the-problem">Approaching the problem</h2>
<p>Switchr is the Gateway API that is the facade/interface to many of the
internal legacy and external 3rd party systems/services. It is a central piece of the overall application architecture.
Ideally every API call to any system or service should go through a central hub such as Switchr in order to gain the full benefits of:
tracing, monitoring, security etc.</p>
<p>Telia have so far not written integration tests for Switchr. Why is this?</p>
<h3 id="rough-calculations">Rough calculations</h3>
<p>Currently Switchr consists of 32 Controllers in 16 areas (business domains).
Each controller typically has between 1-15 controller methods (ie. route handlers), om average perhaps around ~5 methods.
Most controller methods handle multiple scenarios (cases), with one or a more cases.
Each case can either be a failure (exception or error result) or allow continuation or the return of a success response.</p>
<p>Some controller methods are super simple and handle only a single success case. Others handle multiple success and failure cases, up to perhaps
3 success and 10 (or more) failure cases.</p>
<p>More methods are simple than complex, so a rough estimate is that on average each controller handles around ~5 cases in total.
Each case must handle both the invalid/error state and the valid/ok state. So in total around ~10 combinations.</p>
<p>32 controllers x 5 methods x 10 scenario case states = 320 x 5 = ~1600 state cases to be tested</p>
<p>Clearly this is a lot to cover by writing tests, so it is important that a good strategy is chosen.</p>
<h3 id="strategies-for-writing-test-code">Strategies for writing test code</h3>
<p>A &quot;naive&quot; approach might well require up to ~20-30 LOC for each state case tested, which would result in roughly 30-40K LOC.</p>
<p>A &quot;smart&quot; approach could reduce this to ~5 LOC for each, resulting in ~6-8K LOC.</p>
<p>A &quot;super smart&quot; Software Factory (smart engine) based approach could reduce this down to a few hundred LOC even down to 0 LOC, with a few thousand LOC for the engine itself.</p>
<p>an additional advantage of the &quot;smart engine&quot; approach, is that it can be entirely decoupled from the application being tested. The engine can thus in large part be reused
across multiple applications, making it easy to migrate the full test suite from one platform to another, such as from MVC to .NEt or
even to a foreign platform/language combination or architecture approach.</p>
<h3 id="strategies-for-writing-application-code">Strategies for writing application code</h3>
<p>The application code can take similar strategies into consideration as for the test code. Typical enterprise code also follows repeatable patterns.
Typical example:</p>
<ul>
<li>validate arguments</li>
<li>match userId with session user</li>
<li>use a service to fetch model for user with given model id</li>
<li>return model fetched</li>
</ul>
<p>The individual steps in this process can be abstracted away into an engine that takes care of all the &quot;nitty gritty&quot; using a generic approach.
This in turn ensures that all code follows a &quot;standard&quot; by way of using the same engine interface instead of relying on devs following
specific coding guidelines at the low level.</p>
<p>A route handler is currently written as follows:</p>
<pre class="hljs"><code><div>[<span class="hljs-meta">HttpGet</span>]
[<span class="hljs-meta">Route(<span class="hljs-meta-string">"{userId}/services"</span>)</span>]
[<span class="hljs-meta">ResponseType(typeof(SuccessResponse&lt;SwitchrUserServicesModel&gt;))</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;IHttpActionResult&gt; <span class="hljs-title">UserEngagement</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> userId</span>)
</span>{
	/ missing userId validation

	<span class="hljs-comment">// match userId with session user</span>
	<span class="hljs-keyword">if</span> (User.UserId() != userId)
	{
		<span class="hljs-comment">// throw error if no match</span>
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SwitchrForbiddenException(ErrorCode.InvalidUserId, <span class="hljs-string">$"Provided userId is different from current user's Id"</span>);
	}

	<span class="hljs-comment">// use service to fetch UserEngagement model for user id of session user</span>
	<span class="hljs-keyword">var</span> userModel = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>._userServicesLogic.GetUserEngagement(User.UserId());

	<span class="hljs-comment">// return packaged result</span>
	<span class="hljs-keyword">return</span> Ok(<span class="hljs-keyword">new</span> SuccessResponse&lt;SwitchrUserServicesModel&gt;(userModel));
}
</div></code></pre>
<p>The above code is very low level, focusing on the how, not on the what. You have to carefully parse the code mentally
in order to remove the boileplate and understand the crux of the functionality.</p>
<p>A route handler could be expressed as follows:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">UserEngagementHandler</span> {
	<span class="hljs-function">Result <span class="hljs-title">Handle</span>(<span class="hljs-params"></span>) </span>{
		NormalizeAndValidateArguments(); <span class="hljs-comment">// handle validation error</span>
		MatchUserId(); <span class="hljs-comment">// handle mis-match error</span>
		<span class="hljs-keyword">return</span> Fetch(<span class="hljs-string">"UserEngagement"</span>); <span class="hljs-comment">// handle fetch error</span>
	}
}
</div></code></pre>
<p>The steps to handle:</p>
<ul>
<li>arguments</li>
<li>fetch the user</li>
</ul>
<p>The steps are repeated across many handlers, so we can abstract that into a few helpers:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">UserEngagementHandler</span> {
	<span class="hljs-function">Result <span class="hljs-title">Handle</span>(<span class="hljs-params"></span>) </span>{
		ArgumentHandler.Handle()
		UserHandler.Handle() <span class="hljs-comment">// handle user errors</span>
		<span class="hljs-keyword">return</span> Fetch(<span class="hljs-string">"Engagement"</span>); <span class="hljs-comment">// handle fetch error</span>
	}
}
</div></code></pre>
<p>We could then:</p>
<ul>
<li>have all such handler classes automatically normalize and validate arguments in a generic fashion</li>
<li>tag this and other such classes to be a <code>User</code> handler, and if such tag detected, call the <code>UserHandler</code></li>
</ul>
<p>A simple way to &quot;tag&quot; a class and inherit base functionality in OOP is to inherit from a base class.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">UserEngagementHandler</span>: <span class="hljs-title">UserHandler</span> {
	<span class="hljs-function">Result <span class="hljs-title">Handle</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">base</span>.Handle()
		<span class="hljs-keyword">return</span> Fetch(<span class="hljs-string">"Engagement"</span>); <span class="hljs-comment">// handle fetch error</span>
	}
}
</div></code></pre>
<p>Another way could be using a Strategy pattern.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">UserEngagementHandler</span> {
	<span class="hljs-function">Result <span class="hljs-title">Handle</span>(<span class="hljs-params"></span>) </span>{
		HandleArguments()
		HandleUser()
		HandleFetch()
		<span class="hljs-keyword">return</span> result;
	}
}
</div></code></pre>
<p>Using strategy pattern to implement concrete step for <code>HandleFetch</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">UserEngagementHandler</span> {
	<span class="hljs-function">Result <span class="hljs-title">HandleFetch</span>(<span class="hljs-params"></span>) </span>{
		Fetch(<span class="hljs-string">"Engagement"</span>); <span class="hljs-comment">// handle fetch error</span>
	}
}
</div></code></pre>
<p>Having simplified and abstracted to this point, we could then express this in a configuration file:</p>
<pre class="hljs"><code><div>{
	<span class="hljs-attr">"handlers"</span>: {
		<span class="hljs-attr">"UserEngagement"</span>: {
			<span class="hljs-attr">"handlers"</span>: [<span class="hljs-string">"UserHandler"</span>],
			<span class="hljs-attr">"fetch"</span>: <span class="hljs-string">"UserEngagement"</span>
		},
		// ...
		<span class="hljs-attr">"UserHandler"</span>: {
			<span class="hljs-attr">"flow"</span>: [
				{
					<span class="hljs-attr">"name"</span>: <span class="hljs-string">"matchUserId"</span>
				}
			]
		}
	},
	<span class="hljs-attr">"services"</span>: [
		<span class="hljs-string">"UserEngagement"</span>: {
			<span class="hljs-attr">"flow"</span>: {
				<span class="hljs-attr">"name"</span>: <span class="hljs-string">"fetchUser"</span>
			},
			// ...
		}
	]
}
</div></code></pre>
<p>At this point we could maintain all the Handlers and Services from the config file and generate the code dynamically (runtime, as source code or both?)
for whatever platform the system needs to run on. This would just require writing a new engine for each target.</p>
<p>The cool thing is that these engines can be designed to play well together, so that f.ex you can generate the application code AND all the test code
from the same declarative specification, killing many birds with one stone. Taking this even further you can generate system documentation
from the specs and even flow diagrams, to automatically visualize the system architecture. The engines can be parameterized or configured to add addtional
tracing, logging, performance metrics etc. at specific points or for the application as a whole. Full spectrum runtime insight into the app, batteries included!</p>
<p>Leverage at its finest.</p>
<p>The automated test factory approach will be described in more detail below.</p>
<p>The cost of this approach is mostly a new conceptual way of thinking about system architecture and how to build systems.
Also, using this approach, C# might not be the ideal target language as it is NOT specifically designed for this purpose, however it can be done
using various approaches.</p>
<p>C# has good support for creating and invoking code dynamically. This dynamic code approach is often leveraged in dynamic languages such as
Ruby and Javascript to vastly cut down on boilerplate.</p>
<h2 id="writing-application-test-code">Writing application test code</h2>
<p>Embarking on writing application test code is a huge undertaking that should ideally be done from the beginning, f.ex using a Test Driven Design (TDD) approach.
However writing tests can be a pain point for many organisations, as it often takes as much time to write the tests as the application code itself,
reducing the &quot;time to market&quot; for new features. On the other hand, not writing tests means that it is &quot;fingers crossed&quot; on each new release.</p>
<h3 id="acceptance-vs-integration-testing">Acceptance vs integration testing</h3>
<p>Acceptance testing, either automated or by having testers manually clicking around in the User Interface can only help to discover a limited set of bugs.
This is due to the system acting as a black box, ie. black box testing.
However what happens if one or more internal system dependencies don't behave as expected in certain scenarios?
These cases can not be captured by Acceptance testing alone, it only tests the surface, not the internals and dependencies/integrations.
To ensure full coverage of all scenarios, internal (inside the box) integration tests are needed.</p>
<h3 id="internal-integration-testing-pros-and-cons">Internal integration testing: pros and cons</h3>
<p>Internal integration test have the following:</p>
<p>pros:</p>
<ul>
<li>acts as quality assurance on each release (only release if tests pass)</li>
<li>can simulate various internal failure scenarios otherwise very difficult or impossible with pure acceptance testing</li>
</ul>
<p>cons:</p>
<ul>
<li>tests can be brittle (sensitive) to system changes, requiring refactoring of all tests</li>
<li>huge maintenance cost and code size and complexity grows</li>
</ul>
<p>Using a naive approach, the tests can only be written when the underlying system to be tested has reached sufficient stability.
The more tests are written, the higher the cost of any change in the underlying system.</p>
<p>The problem is thus how to best manage pros vs cons, benefits vs costs. Often a compromise is struck, testing only the assumed most critical scenarios as
testing the whole solution is simply deemed too expensive and brittle to change.</p>
<p>Is there a way to achieve the best of both worlds? low cost and maintenance while achieving full test coverage of all scenarios.</p>
<h4 id="approaches">Approaches</h4>
<pre class="hljs"><code><div>[<span class="hljs-meta">Test</span>]
<span class="hljs-keyword">void</span> TestMethodnNme {
	<span class="hljs-comment">// arrange</span>
	<span class="hljs-comment">// act</span>
	<span class="hljs-comment">// assert</span>
}
</div></code></pre>
<ul>
<li>naive hard coded approach (no thought)</li>
<li>naive approach with arrange helpers</li>
<li>naive with generic assertions</li>
</ul>
<h3 id="naive-hardcoded-approach">Naive hardcoded approach</h3>
<p>The simplest approach is the &quot;stupid test code&quot;</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UserEngagementTest_No_Matching_User</span>(<span class="hljs-params"></span>)
</span>{
	<span class="hljs-comment"><span class="hljs-doctag">///</span> arrange</span>
	<span class="hljs-comment">// hard coded test ID :()</span>
	<span class="hljs-keyword">var</span> userId = <span class="hljs-number">617</span>;

	<span class="hljs-comment">// explicit DI and mock setup :()</span>
	<span class="hljs-comment">// create mock of User</span>
	<span class="hljs-comment">// configure DI container explicitly to use this mocked User that ensures match check fails</span>


	<span class="hljs-comment"><span class="hljs-doctag">///</span> act and assert</span>
	<span class="hljs-comment">// hardcoded exception to be matched</span>
	<span class="hljs-comment">// hardcoded single assertion</span>
	Assert.Throws(() =&gt; controller.UserEngagement(userId), SwitchrArgumentException);
}
</div></code></pre>
<p>Pros:</p>
<ul>
<li>uses primitives directly, making it &quot;easy&quot; for any developer who know the specific test, mock, DI and assertion libraries</li>
</ul>
<p>Cons:</p>
<ul>
<li>combines act and assert</li>
<li>on any change of implementation or environment, one or more (up to every) test potentially requires manual change</li>
<li>anti-DRY, leading to COPY/PASTE coding, quick and dirty, resulting in 10s of 1000s lines of code, doesn't scale</li>
<li>can only work if system and environment are &quot;set in stone&quot;</li>
<li>requires an &quot;army&quot; of developers to write and continually maintain</li>
<li>requires 100s or even 1000s of test functions to be manually coded</li>
<li>requires developers to know how to use the particular test, mock and assertion libraries</li>
<li>requires understanding of system architecture, such as injecting mocks into DI container</li>
</ul>
<p>Surely we can do better!</p>
<h3 id="naive-approach">Naive approach</h3>
<p>We can improve naive approach by removing some of the hardcoding and generalising a bit.
This makes it much easier to maintain and reduces friction to change.
The methods to get argument values or mock application state are abstracted away and can be implemented
in whatever way, without affecting the test methods. Great win!</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">UserEngagementTest_No_Matching_User</span>(<span class="hljs-params"></span>)
</span>{
	<span class="hljs-comment"><span class="hljs-doctag">///</span> arrange</span>
	<span class="hljs-keyword">var</span> userId = GetValidUserId();
	MockNoMatchingUser();

	<span class="hljs-comment"><span class="hljs-doctag">///</span> act</span>
	<span class="hljs-keyword">var</span> task = controller.UserEngagement(userId);

	<span class="hljs-comment"><span class="hljs-doctag">///</span> assert</span>
	Assert.Throws(() =&gt; controller.UserEngagement(userId), SwitchrArgumentException);
}
</div></code></pre>
<p>Pros:</p>
<ul>
<li>avoid hardcoding arguments/tst data</li>
<li>encapsulate mocking and DI injection of system state in reusable helper functions</li>
</ul>
<p>Cons:</p>
<ul>
<li>requires lots of pairs of methods for getting the argument values (100-200)</li>
<li>requires 100s of Mocking methods for system state</li>
<li>still clearly doesn't scale</li>
<li>requires 1000s of test functions to be manually coded</li>
<li>still combines act and assert</li>
</ul>
<h3 id="naive-with-generic-assertions">Naive with generic assertions</h3>
<p>The naive approach can be improved further with a more generic way to assert the results,
adding helpers such as <code>AssertAsyncException</code> for each typical scenario</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UserEngagementTest_No_Matching_User</span>(<span class="hljs-params"></span>)
</span>{
	<span class="hljs-comment"><span class="hljs-doctag">///</span> arrange</span>
	<span class="hljs-keyword">var</span> userId = GetValidUserId();
	MockNoMatchingUser();

	<span class="hljs-comment"><span class="hljs-doctag">///</span> act</span>
	<span class="hljs-keyword">var</span> task = controller.UserEngagement(userId);

	<span class="hljs-comment"><span class="hljs-doctag">///</span> assert</span>
	AssertAsyncException(task, Exception.NoMatchingUser);
}
</div></code></pre>
<p>Pros:</p>
<ul>
<li>assertion helper deals with handling async (Task) vs sync results</li>
<li>declarative with encapsulation</li>
<li>nice separation of arrange, act and assert</li>
</ul>
<p>Cons:</p>
<ul>
<li>need to trust that assertion helper is correct for the particular result case</li>
<li>still one test method for each scenario (too many methods)</li>
</ul>
<h3 id="using-test-cases">Using Test cases</h3>
<p>We can reduce the number of test methods by using the concept of a paramerized test case.
Each test case defined different states that make up the scenarios we want to test.</p>
<p>If we do this right, we can reduce the number of test methods by a factor of 5,
roughly from ~1600 to ~300. Huge win.</p>
<pre class="hljs"><code><div>	[<span class="hljs-meta">Test</span>]
	[<span class="hljs-meta">TestCase (true, true, true)</span>] <span class="hljs-comment">// OK</span>
	[<span class="hljs-meta">TestCase (false, true, true)</span>] <span class="hljs-comment">// not a valid user</span>
	[<span class="hljs-meta">TestCase (true, false, true)</span>] <span class="hljs-comment">// not a matching user</span>
	[<span class="hljs-meta">TestCase (true, true, false)</span>] <span class="hljs-comment">// user not found</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UserEngagementTest</span> (<span class="hljs-params"><span class="hljs-keyword">bool</span> isValidUser, <span class="hljs-keyword">bool</span> isMatchingUser, <span class="hljs-keyword">bool</span> isUserFound</span>)
	</span>{
		<span class="hljs-keyword">var</span> userId = GetUserId(isValidUser);

		<span class="hljs-keyword">try</span> {
			<span class="hljs-keyword">var</span> result = controller.UserEngagement(userId);

			<span class="hljs-comment">// possibly different types of OK?</span>
			AssertOK(result);
		} <span class="hljs-keyword">catch</span> (Exception e) {
			<span class="hljs-comment">// how to assert for various scenarios?</span>
			<span class="hljs-keyword">if</span> (isMatchingUser) {
				AssertException(ex, Error.MatchingUser)
			} elseif {
				...
			} elseif {
				...
			} ...
		}
	}
</div></code></pre>
<p>Pros:</p>
<ul>
<li>scales better, but still far from ideal</li>
</ul>
<p>Cons:</p>
<ul>
<li>requires some clever logic to test for various kinds of scenario cases (expected results vs actual results)</li>
<li>results in 100s of tests that need to be written manually</li>
<li>prone to manual error, maintaining every combination of scenario cases to test for</li>
</ul>
<p>We can identify that the Test cases follow a distinct pattern of state combinations that are being tested in succession:</p>
<pre class="hljs"><code><div>x - -
- x -
- - x
x x x
</div></code></pre>
<p>Whenever we identify such patterns, we should consider if we can take advantage of and encode the pattern instead of manually duplicating it.</p>
<h4 id="scenario-test-output">Scenario Test output</h4>
<p><img src=".\images\ScenarioTestOutput.png" alt="Scenario Test Output" title="Scenario Test Output example"></p>
<p>Allows managers/testers to see clear output for each integration test. On any error, the release should be aborted (by default).
This could even be integrated as a git hook, to disallow any commit to master that results in any test breaking.</p>
<h4 id="scenario-test-input">Scenario Test input</h4>
<p><img src=".\images\ScenarioTestInput.png" alt="Scenario Test Input" title="Scenario Test Input example"></p>
<p>Allows the managers/testers to add new tests and cases using a GUI such as a web form.</p>
<h3 id="software-factory">Software Factory</h3>
<p>Taking the next step in optimization, we need to break away from conventional ways of writing tests.
We can build a <code>Software Factory</code> to handle all of this tedious boilerplate and leverage all these patterns to an even further extent than we have seen so far.</p>
<p>Pros:</p>
<ul>
<li>test code mostly evaporates, reducing the code footprint by ~80-99% depending on how far this is taken</li>
<li>easy for anyone to maintain tests as no knowledge of the system or libraries used are needed</li>
<li>devs need only declare behavior and states to be tested, engine takes care of the rest</li>
<li>potentially the tests can be loaded from a config file, thus removing the need for explicit test code completely</li>
<li>the test config file can be generated from any UI such as a web interface or Excel spreadsheet, allowing non-developers to &quot;write the tests&quot;</li>
</ul>
<p>Cons:</p>
<ul>
<li>testing engine is a standalone entity, much like a library or framework that needs to be maintained and improved</li>
<li>tests become almost invisible, relying on conventions and &quot;magic&quot; behind the scenes</li>
</ul>
<h4 id="software-factory-vs-manual-code">Software Factory vs manual code</h4>
<p>To better understand the concept of a Software Factory, let's use Car manufacturing as an analogy.</p>
<p>The first cars were created manually by specialized mechanics, including most of the parts that were custom made by each mechanic shop.
Gradually some common parts were crafted by separate specialists. Then in the early 1900s Ford introduced the Car Assembly Plant where
the process and parts were completely standardised, however it was still manual labor at each assembly line station.
Some decades later, more on more of the processes were automated via robots and today, rouhgly 100 years later we see completely automated factories.
Think about the efficiency gains during this historical process. The time and effort saved is astronomical.
Today, most of the Car manufacturing time and costs goes into R&amp;D of the factory and robotics (assembly line automation optimization)
and next to nothing is spent on traditional manual labor. Gone are the workers - automate everything!</p>
<p>In software development we are still in the 1920s era of Henry Ford manual assembly line. We can standardise manual processes with some level of success,
but the process is still mostly manual prone to manual errors. Involving humans always carries numerous risks.</p>
<p>We feel much safer with a car created by full automation than when humans are involved. Same will soon be the case for self driving car.
Humans are prone to error and we all do things slightly differently. Humans are not good robots.</p>
<p>Why not take the next step in software development and build a Software Factory to generate most of the code, using software robots (pluggable assembly lines etc).
This is obviously more difficult to &quot;get right&quot; but the benefits are enormous if done right. In fact in can result in the complete automated manufacture
of both the applicaiton and test code, automatically keeping them in sync. Ie. the test code and application code being directly derived and generated from
the same declarative specifications, ie. DSL (Domain Specific Language).</p>
<p>It might sound far fetched, but it is definitely possible.</p>
<p>Pros:</p>
<ul>
<li>common language (DSL/specs) to declaratively describe application expected functionality, dependencies and contraints</li>
<li>application &quot;skeleton&quot; code generated from these specs, with only the outer ring of code being tied to concrete implementations</li>
<li>test code tests the API and thus can be entirely generated from the same specs (tests should never be aware of concrete system properties or dependencies)</li>
<li>can be done incrementally</li>
<li>code footprint can be reduced by ~80-99% for both application and test code</li>
<li>application and test code can be generated from the same specs and be kept in sync &quot;out of the box&quot;</li>
<li>benefits multiply and scale up the further you go with this approach</li>
</ul>
<p>Cons:</p>
<ul>
<li>takes more time and effor to initially write Software Factories than following traditional naive approach</li>
<li>initial cost before real benefits kick in</li>
<li>only pays for medium to large applications (at least ~5K LOC or more) as factory (engine) code is typically in the range of ~1-2K LOC</li>
</ul>
<p>Take away:</p>
<p>Once you take this approach you will never want to go back to traditional manual application development for large scale systems.</p>
<h4 id="patterns-to-leverage">Patterns to leverage</h4>
<p>We can see that for each controller method to be tested, we want to test each of the scenarios for both <code>valid</code> and <code>invalid</code> cases.</p>
<ul>
<li>valid user, invalid user</li>
<li>mathing user, not matching user</li>
<li>user can be found, user can not be found</li>
<li>...</li>
</ul>
<p>We can identify each of these scenarios by a name:</p>
<ul>
<li><code>validUser</code></li>
<li><code>matchingUser</code></li>
<li><code>userFound</code></li>
<li>...</li>
</ul>
<p>Then we can have the engine pass generate the full set of states, such as:</p>
<ul>
<li><code>{&quot;validUser&quot;: false, &quot;matchingUser&quot;: true, &quot;userFound&quot;: true}</code> - not a valid user</li>
<li>{&quot;validUser&quot;: true, &quot;matchingUser&quot;: false, &quot;userFound&quot;: true} - not a matching user</li>
<li>...</li>
<li>{&quot;validUser&quot;: true, &quot;matchingUser&quot;: false, &quot;userFound&quot;: true} - OK</li>
</ul>
<p>For each of these case scenarios, the engine should set up the system to be in that given state.</p>
<p><code>SetSystemState(string scenarioCase, bool state)</code></p>
<p>The tests will in general reflect the system (or function) being tested. A controller method such as <code>UserEngagement</code> uses Argument and User handlers
to handle validation of arguments and matching and fetching the user. Naturally we will want to leverage this in a similar way for the test cases.</p>
<p>The scenarios in the controller method will need to be tested in all sensible combinations. We can leverage this fact to set up a map of expected conditions
for each test case to be tested.</p>
<ul>
<li><code>AddArgState</code> argument state (valid/invalid)</li>
<li><code>AddException</code> exception (expected on invalid/failure)</li>
<li><code>AddError</code> error result (expected on invalid/failure)</li>
<li><code>AddSuccess</code> success result on valid (expected on multiple states valid - usually all)</li>
</ul>
<p>We can define a method which configures these case mappings loosely as follows:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// basic setup for all tests that:</span>
<span class="hljs-comment">// - validates a requested user</span>
<span class="hljs-comment">// - matches user requested against principal (session user)</span>
<span class="hljs-comment">// - fetches the user</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ScenarioSetUp</span> (<span class="hljs-params"></span>)
</span>{
	AddArgState(<span class="hljs-string">"userId"</span>, <span class="hljs-string">"validUser"</span>);

	AddException&lt;SwitchrForbiddenException&gt;(<span class="hljs-string">"validUser"</span>, ErrorCode.InvalidUserId);
	AddException&lt;SwitchrForbiddenException&gt;(<span class="hljs-string">"matchingUser"</span>, ErrorCode.InvalidUserId);
	AddException&lt;SwitchrException&gt;(<span class="hljs-string">"userFound"</span>, ErrorCode.UserNotFound);
}
</div></code></pre>
<p>In addition we can group multiple cases into groups, such as &quot;user&quot;</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Setup</span>(<span class="hljs-params"></span>) </span>{
	AddScenarioCaseSet(<span class="hljs-string">"user"</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span>[] { <span class="hljs-string">"validUser"</span>, <span class="hljs-string">"matchingUser"</span>, <span class="hljs-string">"userFound"</span>});
}
</div></code></pre>
<p>The engine can then loop through all the case sets defined for the test in question, and generate case value combinations such as:</p>
<ul>
<li><code>{&quot;validUser&quot;: false, &quot;matchingUser&quot;: true, &quot;userFound&quot;: true}</code> - not a valid user</li>
</ul>
<p>Just like with the original controller method, we find that a method is a bad abstraction in OOP. Instead we need to use a Higher Order Function (HOF)
which is usually in the form of a class in OOP. The class instance (object) is used to maintain the scope (state).</p>
<p>Knowing this, we creaete a class <code>UserTestConfig</code> with the configurations for test setup for handling the user cases and to register the &quot;user&quot; case set:</p>
<ul>
<li><code>validUser</code></li>
<li><code>matchingUser</code></li>
<li><code>userFound</code></li>
<li>...</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">UserTestConfig</span>
{
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ScenarioSetUp</span> (<span class="hljs-params"></span>)
	</span>{
		ConfigureArgs()
		ConfigureExceptions()
		<span class="hljs-comment">// ...</span>
		ConfigureScenariosSets()
	}
}
</div></code></pre>
<p>It's perhaps OK to inherit one level to leverage Strategy pattern <img class="emoji" alt="wink" src="data:image/png;base64,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" /></p>
<pre class="hljs"><code><div><span class="hljs-comment">// basic setup for all tests that:</span>
<span class="hljs-comment">// - validates a requested user</span>
<span class="hljs-comment">// - matches user requested against principal (session user)</span>
<span class="hljs-comment">// - fetches the user</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">UserTestConfig</span>: <span class="hljs-title">TestConfig</span> {
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureArgs</span> (<span class="hljs-params"></span>) </span>{
		AddArgState(<span class="hljs-string">"userId"</span>, <span class="hljs-string">"validUser"</span>);
	}

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureExceptions</span>(<span class="hljs-params"></span>) </span>{
		AddException&lt;SwitchrForbiddenException&gt;(<span class="hljs-string">"validUser"</span>, ErrorCode.InvalidUserId);
		AddException&lt;SwitchrForbiddenException&gt;(<span class="hljs-string">"matchingUser"</span>, ErrorCode.InvalidUserId);
		AddException&lt;SwitchrException&gt;(<span class="hljs-string">"userFound"</span>, ErrorCode.UserNotFound);
	}

	<span class="hljs-comment">// Register scenario sets etc</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureScenariosSets</span>(<span class="hljs-params"></span>) </span>{
		AddScenarioSet(<span class="hljs-string">"user"</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span>[] { <span class="hljs-string">"validUser"</span>, <span class="hljs-string">"matchingUser"</span>, <span class="hljs-string">"userFound"</span>});
	}
}
</div></code></pre>
<p>We can see that these configuration are of a sufficient declarative form that they can be further simplified and loaded from a config file (data source) of some form.</p>
<p><code>test/integration/configurations/User.json</code></p>
<pre class="hljs"><code><div>{
	<span class="hljs-string">"arguments"</span> {
		<span class="hljs-string">"userId"</span>: <span class="hljs-string">"validUser"</span>
	},
	<span class="hljs-string">"exceptions"</span>: {
		<span class="hljs-string">"validUser"</span>: {
			<span class="hljs-string">"exceptionType"</span>: <span class="hljs-string">"forbidden"</span>,
			<span class="hljs-string">"code"</span>: <span class="hljs-string">"InvalidUserId"</span>
		},
		<span class="hljs-comment">// ...</span>
	},
	<span class="hljs-string">"sets"</span>: {
		<span class="hljs-string">"user"</span>: [<span class="hljs-string">"validUser"</span>, <span class="hljs-string">"matchingUser"</span>, <span class="hljs-string">"userFound"</span>]
	}
}
</div></code></pre>
<h3 id="applying-test-configurations">Applying test configurations</h3>
<p>The naive approach would be to inherit from this class, but we should always prefer composition to inheritance.
Instead we can register <code>UserTestConfig</code>:</p>
<p><code>Register(&quot;User&quot;, UserTestConfig);</code></p>
<p>Then in our concrete Test class for the controller method to test, we specify what configurations we wish to apply:</p>
<pre class="hljs"><code><div>[<span class="hljs-meta">SetUp</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetUp</span> (<span class="hljs-params"></span>) </span>{
	ConfigureFor(<span class="hljs-string">"User"</span>);
}
</div></code></pre>
<h3 id="test-setup-and-teardown">Test setup and teardown</h3>
<p>In full, the setup and teardown would look sth like this:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">namespace</span> <span class="hljs-title">Switchr.API.Tests.Controllers.UserController</span>
{
	[<span class="hljs-meta">TestFixture</span>]
	<span class="hljs-keyword">class</span> <span class="hljs-title">UserEngagementTest</span>
	{

		[<span class="hljs-meta">TearDown</span>]
		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TearDown</span>(<span class="hljs-params"></span>)
		</span>{
			<span class="hljs-keyword">base</span>.Cleanup();
			<span class="hljs-comment">// custom cleanup</span>
		}

		[<span class="hljs-meta">SetUp</span>]
		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetUp</span> (<span class="hljs-params"></span>) </span>{
			SetupUsing(<span class="hljs-string">"User"</span>);
			<span class="hljs-comment">// custom cleanup</span>
		}

		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ScenarioTearDown</span>(<span class="hljs-params"></span>)
		</span>{
			<span class="hljs-keyword">base</span>.ScenarioTearDown();
			<span class="hljs-comment">// custom cleanup</span>
		}

		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ScenarioSetUp</span> (<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">base</span>.ScenarioSetUp();
			<span class="hljs-comment">// custom cleanup</span>
		}
	}
}
</div></code></pre>
<p>Potentially we can tag the test class as &quot;User&quot; and it will know by this fact to configure itself as needed using conventions.</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">class</span> <span class="hljs-title">UserControllerTest</span> {
	<span class="hljs-comment">// auto configure setup/teardown</span>
	<span class="hljs-keyword">public</span> typeTags = <span class="hljs-keyword">string</span>[] { <span class="hljs-string">"User"</span> };

	<span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>A generic approach such as this always carries additional advantages such as enabling us to use this information runtime to:
trace, log or tag various output appropriately.</p>
<p>Here the config for <code>CreateUser</code> controller method.</p>
<pre class="hljs"><code><div>class CreateUserTestConfig
{
	// could be auto-loaded from config file
	public void ConfigureErrors() {
		//// CreateUser
		AddArgException(&quot;userDetails&quot;, ErrorCode.ErrorWhenAddingUser, &quot;data&quot;);
		AddArgException(&quot;customerInfo&quot;, ErrorCode.ErrorWhenAddingUser, &quot;customer&quot;);
		AddArgException(&quot;adminConfig&quot;, ErrorCode.ErrorWhenAddingUser, &quot;admin&quot;);
	}
}
</div></code></pre>
<p>Then register it...</p>
<p>We could then tag the class with both <code>User</code> and <code>CreateUser</code> to apply configs for both</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> typeTags = <span class="hljs-keyword">string</span>[] { <span class="hljs-string">"User"</span>, <span class="hljs-string">"CreateUser"</span> };
</div></code></pre>
<p>Alternatively we could make the <code>CreateUser</code> config apply the config of <code>User</code></p>
<pre class="hljs"><code><div>class CreateUserTestConfig
{
	public typeTags = string[] { &quot;User&quot; };
}
</div></code></pre>
<p>Much better <img class="emoji" alt="smiley" src="data:image/png;base64,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" /></p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> typeTags = <span class="hljs-keyword">string</span>[] { <span class="hljs-string">"CreateUser"</span> };
</div></code></pre>
<p>However now we see an additional pattern that the class name <code>CreateUserTest</code> is almost identical to the type tag.
Should we further take advantage of this fact and automatically apply any configuration of class name with <code>Test</code> removed?
Perhaps this is overkill for now!?</p>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">CreateUserTest</span>: <span class="hljs-title">ScenarioTest</span> {

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RunScenario</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> scenarioLabel, Dictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">bool</span>&gt; scenarioStates</span>) </span>{
		Arrange()
		Act()
		Assert()
	}

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Arrange</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-comment">// ...</span>
	}

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Act</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-comment">// ...</span>
	}

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Assert</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-comment">// ...</span>
	}
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">CreateUserTest</span>: <span class="hljs-title">ScenarioTest</span> {
	<span class="hljs-comment">// auto configure setup/teardown</span>
	<span class="hljs-comment">// public typeTags = string[] { "CreateUser" };</span>
	<span class="hljs-keyword">public</span> MethodName = <span class="hljs-string">"CreateUser"</span>;

	[<span class="hljs-meta">Test</span>]
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateUserTestCases</span>(<span class="hljs-params"></span>)
	</span>{
		TestScenarios&lt;UserController&gt;();
	}

	<span class="hljs-comment">// scenario name being tested</span>
	<span class="hljs-comment">// scenario states for that scenario</span>
	<span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RunScenario</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> scenarioLabel, Dictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">bool</span>&gt; scenarioStates</span>)
	</span>{
		<span class="hljs-comment">// ...</span>
	}

	<span class="hljs-comment"><span class="hljs-doctag">///</span>/ Arrange</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Arrange</span>(<span class="hljs-params"></span>) </span>{

		SetScenarioLabel(ScenarioLabel);
		SetScenariosStates(ScenarioStates);
	}

	<span class="hljs-comment"><span class="hljs-doctag">///</span> prepare instance</span>
	<span class="hljs-comment">// ensure everything is fully configured before creating controller to test on</span>

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrepareInstance</span>(<span class="hljs-params"></span>) </span>{
		SetupController&lt;UserController&gt;();
	}

	<span class="hljs-comment"><span class="hljs-doctag">///</span> act</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Act</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">var</span> result = RunAsyncControllerMethod&lt;UserController&gt;();
	}

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Assert</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-comment">// generic assertion based on expected result and actual result</span>
		<span class="hljs-comment">// also handles async Task vs synchronous</span>
		AssertIt(result);
	}
}
</div></code></pre>
<p>From this code we can see that it is entirely generic and can be generated runtime from a configuration file as well.
We can use this pattern to customize as needed.</p>
<p>The ideal approach is to generated the default generic tests by default if a concrete scenario test method is not provided.</p>
<p>The perfect methodology would be to use the engine by default.
In cases where the engine does not cover a concrete method to be tested, override the method <code>RunScenario</code> and implement
what is missing using a combination of engine building blocks and custom code.
Gradually move custom code into the engine so that most ~80% of cases are handled by the engine. Ideally get to a stage where no custom test code is needed
and all can be loaded, generated and run from a configuration file that can be maintained by non-technical experts (f.ex business users).</p>
<h2 id="configuring-mocked-dependencies">Configuring Mocked Dependencies</h2>
<p>The <code>dependencyMap</code> is used to set up the map of dependency mocks needed for the scenario.</p>
<p>Example:</p>
<pre class="hljs"><code><div>AddFor(<span class="hljs-string">"userFound"</span>).Dependency(<span class="hljs-string">"IUserManager"</span>).MethodCall(<span class="hljs-string">"GetUser"</span>).AnyArgs().Returns(Result.IsNull);
</div></code></pre>
<p>This implies that we want to setup the <code>IUserManager</code> dependency in the DI container with a mocked <code>IUserManager</code>.
The mock should mock the call to <code>GetUser</code> and on returning any arguments, it should always return null.</p>
<p>We could also use <code>ArgsFor(&quot;validUser&quot;)</code> to mean that for the argument for <code>&quot;validUser&quot;</code> (such as <code>617</code>) we should return <code>null</code>, other function normally.</p>
<pre class="hljs"><code><div>ArgsFor(<span class="hljs-string">"validUser"</span>).Returns(Result.IsNull);
</div></code></pre>

</body>
</html>
